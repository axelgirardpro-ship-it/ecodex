{"version":3,"sources":["../../../../src/core/serialization/assistant-transport/AssistantTransport.ts"],"sourcesContent":["import { AssistantStreamChunk } from \"../../AssistantStreamChunk\";\nimport { PipeableTransformStream } from \"../../utils/stream/PipeableTransformStream\";\nimport { LineDecoderStream } from \"../../utils/stream/LineDecoderStream\";\nimport { AssistantStreamEncoder } from \"../../AssistantStream\";\n\n/**\n * AssistantTransportEncoder encodes AssistantStreamChunks into SSE format\n * and emits [DONE] when the stream completes.\n */\nexport class AssistantTransportEncoder\n  extends PipeableTransformStream<AssistantStreamChunk, Uint8Array<ArrayBuffer>>\n  implements AssistantStreamEncoder\n{\n  headers = new Headers({\n    \"Content-Type\": \"text/event-stream\",\n    \"Cache-Control\": \"no-cache\",\n    Connection: \"keep-alive\",\n  });\n\n  constructor() {\n    super((readable) => {\n      return readable\n        .pipeThrough(\n          new TransformStream<AssistantStreamChunk, string>({\n            transform(chunk, controller) {\n              controller.enqueue(`data: ${JSON.stringify(chunk)}\\n\\n`);\n            },\n            flush(controller) {\n              controller.enqueue(\"data: [DONE]\\n\\n\");\n            },\n          }),\n        )\n        .pipeThrough(new TextEncoderStream());\n    });\n  }\n}\n\ntype SSEEvent = {\n  event: string;\n  data: string;\n  id?: string | undefined;\n  retry?: number | undefined;\n};\n\nclass SSEEventStream extends TransformStream<string, SSEEvent> {\n  constructor() {\n    let eventBuffer: Partial<SSEEvent> = {};\n    let dataLines: string[] = [];\n\n    super({\n      start() {\n        eventBuffer = {};\n        dataLines = [];\n      },\n      transform(line, controller) {\n        if (line.startsWith(\":\")) return; // Ignore comments\n\n        if (line === \"\") {\n          if (dataLines.length > 0) {\n            controller.enqueue({\n              event: eventBuffer.event || \"message\",\n              data: dataLines.join(\"\\n\"),\n              id: eventBuffer.id,\n              retry: eventBuffer.retry,\n            });\n          }\n          eventBuffer = {};\n          dataLines = [];\n          return;\n        }\n\n        const [field, ...rest] = line.split(\":\");\n        const value = rest.join(\":\").trimStart();\n\n        switch (field) {\n          case \"event\":\n            eventBuffer.event = value;\n            break;\n          case \"data\":\n            dataLines.push(value);\n            break;\n          case \"id\":\n            eventBuffer.id = value;\n            break;\n          case \"retry\":\n            eventBuffer.retry = Number(value);\n            break;\n        }\n      },\n      flush(controller) {\n        if (dataLines.length > 0) {\n          controller.enqueue({\n            event: eventBuffer.event || \"message\",\n            data: dataLines.join(\"\\n\"),\n            id: eventBuffer.id,\n            retry: eventBuffer.retry,\n          });\n        }\n      },\n    });\n  }\n}\n\n/**\n * AssistantTransportDecoder decodes SSE format into AssistantStreamChunks.\n * It stops decoding when it encounters [DONE].\n */\nexport class AssistantTransportDecoder extends PipeableTransformStream<\n  Uint8Array<ArrayBuffer>,\n  AssistantStreamChunk\n> {\n  constructor() {\n    super((readable) => {\n      let receivedDone = false;\n\n      return readable\n        .pipeThrough(new TextDecoderStream())\n        .pipeThrough(new LineDecoderStream())\n        .pipeThrough(new SSEEventStream())\n        .pipeThrough(\n          new TransformStream<SSEEvent, AssistantStreamChunk>({\n            transform(event, controller) {\n              switch (event.event) {\n                case \"message\":\n                  if (event.data === \"[DONE]\") {\n                    // Mark that we received [DONE]\n                    receivedDone = true;\n                    // Stop processing when we encounter [DONE]\n                    controller.terminate();\n                  } else {\n                    controller.enqueue(JSON.parse(event.data));\n                  }\n                  break;\n                default:\n                  throw new Error(`Unknown SSE event type: ${event.event}`);\n              }\n            },\n            flush() {\n              if (!receivedDone) {\n                throw new Error(\n                  \"Stream ended abruptly without receiving [DONE] marker\",\n                );\n              }\n            },\n          }),\n        );\n    });\n  }\n}\n"],"mappings":"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","names":[]}